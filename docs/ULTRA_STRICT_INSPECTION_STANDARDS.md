# 超严格检查标准 - 零容忍简化实现

## 检查目标

进行最严格的全面检查，确保项目中不存在任何形式的简化实现、占位符、不完整代码或暗示性注释。

## 🔍 扩展关键词列表

### 中文关键词 (零容忍)
**直接简化标识**:
- `简化` `简单` `基础` `基本` `默认` `临时` `暂时` `占位` `示例` `测试`
- `简易` `粗糙` `草率` `快速` `临时性` `过渡` `权宜` `应急`

**暗示性词汇**:
- `应该` `需要` `可以` `可能` `或许` `大概` `估计` `假设` `暂定`
- `待定` `待完善` `待实现` `待优化` `待改进` `待补充` `待扩展`
- `后续` `将来` `未来` `以后` `稍后` `之后` `接下来`

**实现不完整标识**:
- `实际` `真正` `完整` `正式` `生产` `最终` `完善` `详细`
- `充分` `全面` `深入` `彻底` `严格` `精确` `准确` `完备`

**限制性词汇**:
- `目前` `当前` `现在` `暂时` `临时` `初步` `初始` `初级`
- `有限` `受限` `限制` `约束` `简陋` `粗糙` `不足` `缺少`

### 英文关键词 (零容忍)
**直接标识**:
- `TODO` `FIXME` `HACK` `TEMP` `TEMPORARY` `PLACEHOLDER` `MOCK` `FAKE` `STUB` `DUMMY`
- `SIMPLE` `BASIC` `DEFAULT` `QUICK` `ROUGH` `CRUDE` `NAIVE` `TRIVIAL`

**暗示性词汇**:
- `should` `need` `could` `might` `maybe` `probably` `assume` `suppose`
- `pending` `incomplete` `partial` `limited` `minimal` `simplified`

**实现标识**:
- `actual` `real` `complete` `full` `proper` `final` `production` `comprehensive`
- `detailed` `thorough` `robust` `sophisticated` `advanced` `mature`

## 🎯 代码模式检查

### 可疑函数模式
1. **过短函数** - 业务逻辑函数少于5行
2. **单一返回值** - 复杂业务只返回一个简单值
3. **无参数验证** - 没有输入参数检查
4. **无错误处理** - 没有适当的错误处理
5. **硬编码值** - 使用魔法数字或固定字符串
6. **空实现** - 函数体为空或只有注释

### 可疑注释模式
1. **条件性语句** - "如果...则..."、"当...时..."
2. **未来时态** - "将会..."、"会..."、"将要..."
3. **建议性语言** - "建议..."、"推荐..."、"最好..."
4. **解释性过多** - 过度解释为什么这样实现

### 可疑业务逻辑
1. **算法过简** - 复杂业务用简单算法
2. **边界条件缺失** - 没有处理边界情况
3. **配置硬编码** - 配置值写死在代码中
4. **验证不全** - 数据验证不完整

## 🔬 函数复杂度分析标准

### 复杂度指标
1. **行数分析** - 业务函数应有合理行数
2. **分支复杂度** - 应有适当的条件分支
3. **参数验证** - 必须有完整的参数检查
4. **错误处理** - 必须有适当的错误处理
5. **日志记录** - 关键操作必须有日志

### 业务函数最低标准
- **验证函数**: 至少10行，包含多种验证规则
- **计算函数**: 至少15行，考虑多种因素
- **转换函数**: 至少8行，包含错误处理
- **管理函数**: 至少12行，包含状态检查

## 📝 注释分析标准

### 危险注释模式
1. **"这里..."开头** - "这里应该..."、"这里需要..."
2. **"实际..."模式** - "实际应该..."、"实际需要..."
3. **"目前..."模式** - "目前只是..."、"目前暂时..."
4. **"简单..."模式** - "简单处理..."、"简单实现..."
5. **"基本..."模式** - "基本功能..."、"基本实现..."

### 安全注释模式
1. **解释性注释** - 解释为什么这样做
2. **技术性注释** - 说明技术细节
3. **业务性注释** - 说明业务规则
4. **警告性注释** - 提醒注意事项

## 🏗️ 架构完整性检查

### 分层检查
1. **API层** - 是否有完整的参数验证和错误处理
2. **业务层** - 是否实现了完整的业务规则
3. **数据层** - 是否有完整的数据操作和事务处理
4. **工具层** - 是否有完整的工具函数实现

### 功能完整性
1. **CRUD操作** - 增删改查是否都完整实现
2. **错误处理** - 各种错误情况是否都有处理
3. **日志记录** - 关键操作是否都有日志
4. **配置管理** - 配置是否灵活可配置

## 🧪 测试覆盖检查

### 测试完整性
1. **单元测试** - 每个函数是否有对应测试
2. **集成测试** - 模块间交互是否有测试
3. **边界测试** - 边界条件是否有测试
4. **错误测试** - 错误情况是否有测试

### 测试质量
1. **测试数据** - 是否使用真实的测试数据
2. **断言完整** - 是否验证了所有重要结果
3. **覆盖率** - 代码覆盖率是否足够高

## 🔧 修复标准

### 函数实现标准
1. **参数验证** - 必须验证所有输入参数
2. **业务逻辑** - 必须实现完整的业务规则
3. **错误处理** - 必须处理所有可能的错误
4. **日志记录** - 必须记录关键操作
5. **返回值** - 必须返回有意义的结果

### 注释标准
1. **无暗示性语言** - 不能有任何暗示实现不完整的词汇
2. **技术准确性** - 注释必须准确描述实现
3. **业务准确性** - 注释必须准确描述业务逻辑

### 代码质量标准
1. **可读性** - 代码必须清晰易读
2. **可维护性** - 代码必须易于维护
3. **可扩展性** - 代码必须支持未来扩展
4. **性能** - 代码必须有合理的性能

## 🎯 检查流程

### 第一轮：关键词扫描
1. 使用所有关键词进行全项目搜索
2. 记录每个匹配项的位置和上下文
3. 分析每个匹配项是否为问题

### 第二轮：文件逐一审查
1. 按文件类型分组检查
2. 对每个函数进行复杂度分析
3. 检查函数间的调用关系

### 第三轮：业务逻辑验证
1. 验证每个业务函数的完整性
2. 检查算法的合理性
3. 验证错误处理的完整性

### 第四轮：交叉验证
1. 检查函数间的一致性
2. 验证接口实现的完整性
3. 检查配置和常量的合理性

## 🏆 成功标准

项目必须满足以下所有条件：
1. ✅ 零简化实现关键词
2. ✅ 零暗示性注释
3. ✅ 所有函数都有合理复杂度
4. ✅ 所有业务逻辑都完整实现
5. ✅ 所有错误情况都有处理
6. ✅ 所有配置都可配置
7. ✅ 编译和测试100%通过
8. ✅ 代码质量达到生产标准

---

**标准制定时间**: 2025-06-20  
**标准制定人**: Augment Agent  
**目标**: 100%消除任何形式的简化实现
